<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GEARCALC-PRO — Involute Spur Gear (Contact Ratio + Tooth Preview)</title>
  <style>
    :root{
      --bg:#0b1220;
      --card:#0f1b33;
      --card2:#0c1730;
      --text:#e8eefc;
      --muted:#aeb8d6;
      --line:rgba(255,255,255,.10);
      --accent:#7aa2ff;
      --accent2:#3ddc97;
      --warn:#ffcc66;
      --bad:#ff6b6b;
      --good:#52ffa8;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --r: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 900px at 20% -10%, rgba(122,162,255,.22), transparent 60%),
        radial-gradient(900px 700px at 90% 0%, rgba(61,220,151,.12), transparent 55%),
        linear-gradient(180deg, #070c16, var(--bg) 45%, #070c16);
      min-height:100vh;
    }
    header{
      padding:28px 18px 18px;
      max-width:1200px;
      margin:0 auto;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:18px;
    }
    .brand{
      display:flex; flex-direction:column; gap:6px;
    }
    .brand .lab{
      font-size:14px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .brand .title{
      font-size:22px;
      font-weight:750;
      line-height:1.15;
    }
    .brand .subtitle{
      font-size:14px;
      color:var(--muted);
      max-width:720px;
    }
    .pillrow{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;}
    .pill{
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      padding:8px 12px;
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
    }
    main{
      max-width:1200px;
      margin:0 auto;
      padding:0 18px 26px;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:16px;
    }
    @media (max-width: 980px){
      main{grid-template-columns:1fr; }
      .pillrow{justify-content:flex-start;}
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card .head{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background:rgba(255,255,255,.02);
    }
    .card .head h2{
      margin:0;
      font-size:14px;
      letter-spacing:.02em;
      color:var(--text);
      font-weight:700;
    }
    .card .body{ padding:14px 16px; }
    .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }
    .field{
      display:flex; flex-direction:column; gap:6px;
    }
    .field label{
      font-size:12px;
      color:var(--muted);
    }
    .field input, .field select{
      width:100%;
      background:rgba(0,0,0,.22);
      color:var(--text);
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:10px 10px;
      outline:none;
      font-size:13px;
    }
    .field input:focus, .field select:focus{
      border-color:rgba(122,162,255,.55);
      box-shadow: 0 0 0 3px rgba(122,162,255,.18);
    }
    .row{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .btn{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      font-size:13px;
      cursor:pointer;
      transition:.15s transform ease, .15s background ease, .15s border-color ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); background:rgba(255,255,255,.09); border-color:rgba(255,255,255,.18);}
    .btn.primary{
      background:rgba(122,162,255,.18);
      border-color:rgba(122,162,255,.42);
    }
    .btn.primary:hover{ background:rgba(122,162,255,.22); }
    .btn.good{
      background:rgba(61,220,151,.12);
      border-color:rgba(61,220,151,.35);
    }
    .btn.bad{
      background:rgba(255,107,107,.10);
      border-color:rgba(255,107,107,.35);
    }
    .toggle{
      display:flex; align-items:center; gap:8px;
      font-size:13px; color:var(--muted);
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px 14px;
      font-size:13px;
      padding:12px 0;
      border-bottom:1px dashed rgba(255,255,255,.12);
    }
    .kv:last-child{border-bottom:none}
    .kv .k{ color:var(--muted); }
    .kv .v{ font-family:var(--mono); color:var(--text); }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
      font-size:13px;
      color:var(--muted);
    }
    .badge strong{ color:var(--text); font-family:var(--mono); }
    .status{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.20);
      font-size:13px;
      color:var(--muted);
    }
    .status.ok{ border-color:rgba(82,255,168,.28); }
    .status.warn{ border-color:rgba(255,204,102,.35); }
    .status.bad{ border-color:rgba(255,107,107,.35); }
    .status .mono{ font-family:var(--mono); color:var(--text); }
    .canvasWrap{
      padding:12px;
      display:flex; flex-direction:column; gap:10px;
    }
    canvas{
      width:100%;
      height:520px;
      background:linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,.12));
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
    }
    .footer{
      max-width:1200px;
      margin:0 auto;
      padding:10px 18px 26px;
      color:rgba(255,255,255,.55);
      font-size:12px;
      display:flex;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .footer .copy{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:12px;
      padding:10px 12px;
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
  </style>
</head>

<body>
<header>
  <div class="brand">
    <div class="lab">Machine Design Laboratory — NTUA</div>
    <div class="title">GEARCALC-PRO (Demo V1)</div>
    <div class="subtitle">
      Involute spur gear contact ratio (ε<sub>α</sub>) with a geometric tooth preview and CSV exports.
    </div>
  </div>
  <div class="pillrow">
    <div class="pill">Static HTML/JS</div>
    <div class="pill">Involute LOA extraction</div>
    <div class="pill">Rack fillet + gear generator</div>
  </div>
</header>

<main>
  <!-- LEFT: Inputs & Results -->
  <section class="card">
    <div class="head">
      <h2>Inputs</h2>
      <button class="btn primary" id="btnCompute">Compute</button>
    </div>
    <div class="body">
      <div class="grid">
        <div class="field">
          <label>Module m (mm)</label>
          <input id="m" type="number" step="0.01" value="3">
        </div>
        <div class="field">
          <label>Pressure angle α (deg)</label>
          <input id="alpha" type="number" step="0.01" value="20">
        </div>

        <div class="field">
          <label>Pinion teeth z₁</label>
          <input id="z1" type="number" step="1" value="30">
        </div>
        <div class="field">
          <label>Gear teeth z₂</label>
          <input id="z2" type="number" step="1" value="31">
        </div>

        <div class="field">
          <label>Addendum coeff Ck</label>
          <input id="Ck" type="number" step="0.01" value="1.00">
        </div>
        <div class="field">
          <label>Dedendum coeff Cf</label>
          <input id="Cf" type="number" step="0.01" value="1.25">
        </div>

        <div class="field">
          <label>Rack fillet radius target r<sub>c</sub> (mm)</label>
          <input id="rc" type="number" step="0.01" value="0.30">
        </div>
        <div class="field">
          <label>Sampling points (contact path)</label>
          <input id="N" type="number" step="50" value="1200">
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <label class="toggle"><input type="checkbox" id="showGear" /> Show full gear outline</label>
        <label class="toggle"><input type="checkbox" id="showCircles" checked /> Show reference circles</label>
        <label class="toggle"><input type="checkbox" id="autoCompute" checked /> Auto-update</label>
      </div>

      <div class="status" id="statusBox" style="margin-top:12px;">
        Ready.
      </div>
    </div>
  </section>

  <!-- RIGHT: Results + Canvas -->
  <section class="card">
    <div class="head">
      <h2>Results & Geometry Preview</h2>
      <div class="row">
        <button class="btn good" id="btnCSV_Profile">Download profile CSV</button>
        <button class="btn good" id="btnCSV_Tooth">Download tooth CSV</button>
        <button class="btn" id="btnCSV_Gear">Download full gear CSV</button>
      </div>
    </div>

    <div class="body">
      <div class="row" style="gap:12px; flex-wrap:wrap;">
        <div class="badge">ε<sub>α</sub>: <strong id="eps">—</strong></div>
        <div class="badge">LOA length: <strong id="loaLen">—</strong></div>
        <div class="badge">Base pitch p<sub>b</sub>: <strong id="pb">—</strong></div>
      </div>

      <div style="margin-top:12px;" class="card" aria-hidden="true">
        <div class="body" style="padding:12px 16px;">
          <div class="kv">
            <div class="k">Pinion pitch radius r₁ (mm)</div><div class="v" id="r1">—</div>
            <div class="k">Pinion base radius r<sub>b1</sub> (mm)</div><div class="v" id="rb1">—</div>
            <div class="k">Pinion addendum radius r<sub>a1</sub> (mm)</div><div class="v" id="ra1">—</div>
            <div class="k">Pinion root radius r<sub>f1</sub> (mm)</div><div class="v" id="rf1">—</div>
          </div>
        </div>
      </div>

      <div class="canvasWrap">
        <canvas id="cv"></canvas>

        <div class="row" style="justify-content:space-between; gap:12px;">
          <div class="row" style="gap:10px; flex-wrap:wrap;">
            <div class="field" style="min-width:220px;">
              <label>FEA segment export</label>
              <select id="segSelect">
                <option value="rootL">01_rootCircle_L</option>
                <option value="troL">02_trochoid_L</option>
                <option value="invL">03_involute_L</option>
                <option value="add">04_addendumArc</option>
                <option value="invR">05_involute_R</option>
                <option value="troR">06_trochoid_R</option>
                <option value="rootR">07_rootCircle_R</option>
              </select>
            </div>
            <button class="btn" id="btnCSV_Segment">Download selected segment CSV</button>
          </div>
          <div class="pill" style="align-self:flex-end;">Units: mm</div>
        </div>
      </div>
    </div>
  </section>
</main>

<div class="footer">
  <div class="copy">
    © <span id="year"></span> Machine Design Lab, National Technical University of Athens (NTUA). All rights reserved.
  </div>
  <div class="copy">
    GEARCALC-PRO Demo V1 — published via GitHub Pages.
  </div>
</div>

<script>
/* ============================================================
   GEARCALC-PRO DEMO V1 (Single-file)
   - Involute rack generation -> LOA extraction -> profile
   - rack_fillet_v2 (ported) -> root completion
   - gear_generator (ported) -> full gear + FEA segments
   CHANGE REQUEST APPLIED:
   - The "tooth preview / tooth CSV" is now the SECTOR boundary whose
     root-circle parts are CUT at θ = ±π/Z (root circle trimmed at -π/Z and +π/Z).
     Full gear outline remains unchanged.
   ============================================================ */

(function(){
  "use strict";

  // ---------- DOM ----------
  const el = (id) => document.getElementById(id);

  const ui = {
    m: el("m"), alpha: el("alpha"), z1: el("z1"), z2: el("z2"),
    Ck: el("Ck"), Cf: el("Cf"), rc: el("rc"), N: el("N"),
    showGear: el("showGear"), showCircles: el("showCircles"), autoCompute: el("autoCompute"),
    btnCompute: el("btnCompute"),
    eps: el("eps"), loaLen: el("loaLen"), pb: el("pb"),
    r1: el("r1"), rb1: el("rb1"), ra1: el("ra1"), rf1: el("rf1"),
    status: el("statusBox"),
    cv: el("cv"),
    btnCSV_Profile: el("btnCSV_Profile"),
    btnCSV_Tooth: el("btnCSV_Tooth"),
    btnCSV_Gear: el("btnCSV_Gear"),
    segSelect: el("segSelect"),
    btnCSV_Segment: el("btnCSV_Segment")
  };

  el("year").textContent = new Date().getFullYear();

  // ---------- App state ----------
  const state = {
    last: null,              // last computed base bundle
    lastProfilePP: null,     // {x_pp,y_pp} pitch-point frame profile
    lastTooth: null,         // {x_tooth,y_tooth}  (NOW: sector boundary cut at ±π/Z)
    lastGear: null,          // {x_tot,y_tot}      (legacy full gear)
    lastSeg: null,           // seg struct
    lastLOA: null            // {x_LOA,y_LOA}
  };

  // ---------- Helpers ----------
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function deg2rad(d){ return d*Math.PI/180; }
  function fmt(v, nd=6){
    if (!isFinite(v)) return "—";
    const s = v.toFixed(nd);
    return s.replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'');
  }
  function setStatus(kind, msg){
    ui.status.className = "status " + (kind || "");
    ui.status.innerHTML = msg;
  }
  function downloadCSV(filename, rows){
    const csv = rows.map(r => r.join(",")).join("\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  function linspace(a,b,n){
    if (n<=1) return [a];
    const arr = new Array(n);
    const step = (b-a)/(n-1);
    for (let i=0;i<n;i++) arr[i] = a + step*i;
    return arr;
  }
  function rotateXY(x, y, ang){
    const c = Math.cos(ang), s = Math.sin(ang);
    return [ x*c - y*s, x*s + y*c ];
  }

  // Five-point non-uniform derivative (ported from MATLAB)
  function fivePointNonUniformDerivative(x, f){
    const n = x.length;
    if (n < 5) throw new Error("At least 5 points are required for 5-point derivative.");
    const dfdx = new Array(n).fill(0);
    for (let i=0;i<n;i++){
      let idx;
      if (i <= 1) idx = [0,1,2,3,4];
      else if (i >= n-2) idx = [n-5,n-4,n-3,n-2,n-1];
      else idx = [i-2,i-1,i,i+1,i+2];

      const xsub = idx.map(j => x[j]);
      const fsub = idx.map(j => f[j]);
      const h = xsub.map(xx => xx - x[i]);

      const w = new Array(5).fill(0);
      for (let j=0;j<5;j++){
        let denom = 1;
        for (let m=0;m<5;m++){
          if (m !== j) denom *= (h[j] - h[m]);
        }
        let num = 0;
        for (let m=0;m<5;m++){
          if (m === j) continue;
          let prod = 1;
          for (let k=0;k<5;k++){
            if (k !== j && k !== m) prod *= (-h[k]);
          }
          num += prod;
        }
        w[j] = num / denom;
      }
      let val = 0;
      for (let j=0;j<5;j++) val += w[j]*fsub[j];
      dfdx[i] = val;
    }
    return dfdx;
  }

  // ---------- Arc helper (legacy convention: x=r sinθ, y=r cosθ) ----------
  function arcXY(r, th1, th2, N, includeEnds){
    const pts = [];
    if (N < 2) N = 2;
    let th;
    if (includeEnds){
      th = linspace(th1, th2, N);
    } else {
      th = linspace(th1, th2, N+2).slice(1,-1);
    }
    for (let i=0;i<th.length;i++){
      const t = th[i];
      pts.push([ r*Math.sin(t), r*Math.cos(t) ]);
    }
    return pts;
  }

  // ---------- Core: LOA extraction + profile generation ----------
  function computeInvoluteLOAandProfile({ m, z1, z2, alphaRad, Ck, Cf, N }){
    if (!(m>0)) throw new Error("Module m must be > 0.");
    if (!(z1>=3 && Number.isInteger(z1))) throw new Error("z1 must be an integer ≥ 3.");
    if (!(z2>=3 && Number.isInteger(z2))) throw new Error("z2 must be an integer ≥ 3.");
    if (!(alphaRad>0 && alphaRad<Math.PI/2)) throw new Error("Pressure angle must be in (0, 90°).");
    if (!(Ck>0 && Cf>0)) throw new Error("Ck and Cf must be > 0.");
    if (!(N>=200 && Number.isFinite(N))) throw new Error("Sampling points must be ≥ 200.");

    const ro1 = z1*m/2;
    const ro2 = z2*m/2;
    const rb1 = ro1*Math.cos(alphaRad);
    const rb2 = ro2*Math.cos(alphaRad);

    const hk = Ck*m;
    const hf = Cf*m;
    const ra1 = ro1 + hk;
    const ra2 = ro2 + hk;

    // Rack line
    const yr = linspace(-Cf*m, Ck*m, N);
    const xr = yr.map(v => -Math.tan(alphaRad)*v);

    // Keep pipeline-compatible derivative form
    // const dydx = fivePointNonUniformDerivative(xr, yr);
    const dydx = yr.map(() => -1/Math.tan(alphaRad)); // exact for the line

    // Rack translation K and corresponding pinion rotation
    const K = yr.map((y,i) => -(y*dydx[i] + xr[i]));
    const theta = K.map(k => k / ro1);

    // Contact path (pitch-point frame)
    const xcp = xr.map((x,i) => x + K[i]);
    const ycp = yr.slice();

    // LOA region: inside both addendum circles
    const mask = xcp.map((x,i) => {
      const y = ycp[i];
      const rA1 = Math.hypot(x, y + ro1);
      const rA2 = Math.hypot(x, y - ro2);
      return (rA1 <= ra1) && (rA2 <= ra2);
    });

    // Longest contiguous true-run
    let runs = [];
    let inRun = false;
    let s = 0;
    for (let i=0;i<mask.length;i++){
      if (!inRun && mask[i]){ inRun=true; s=i; }
      if (inRun && (!mask[i] || i===mask.length-1)){
        const e = (mask[i] && i===mask.length-1) ? i : (i-1);
        runs.push([s,e]);
        inRun=false;
      }
    }
    if (runs.length === 0) throw new Error("LOA extraction failed: no points inside both addendum circles.");

    let best = runs[0], bestLen = -1;
    for (const [a,b] of runs){
      let L = 0;
      for (let k=a;k<b;k++){
        const dx = xcp[k+1]-xcp[k];
        const dy = ycp[k+1]-ycp[k];
        L += Math.hypot(dx,dy);
      }
      if (L > bestLen){ bestLen = L; best=[a,b]; }
    }
    const [i0,i1] = best;

    const xLOA = xcp.slice(i0, i1+1);
    const yLOA = ycp.slice(i0, i1+1);
    const thLOA = theta.slice(i0, i1+1);
    const KLOA = K.slice(i0, i1+1);

    // Pinion profile in pitch-point frame
    const xPP = new Array(xLOA.length);
    const yPP = new Array(xLOA.length);
    for (let i=0;i<xLOA.length;i++){
      const x = xLOA[i], y = yLOA[i], th = thLOA[i];
      xPP[i] =  x*Math.cos(th) - (y + ro1)*Math.sin(th);
      yPP[i] =  x*Math.sin(th) + (y + ro1)*Math.cos(th) - ro1;
    }

    const loaLen = bestLen;
    const pb = Math.PI*m*Math.cos(alphaRad);
    const eps = loaLen / pb;

    return {
      ro1, ro2, rb1, rb2, ra1, ra2,
      rf1: ro1 - hf,
      m, z1, z2, alphaRad, Ck, Cf,
      xLOA, yLOA, thLOA, KLOA,
      xrLOA: xLOA.map((x,i)=> x - KLOA[i]),
      yrLOA: yLOA.slice(),
      xPP, yPP,
      loaLen, pb, eps
    };
  }

  // ---------- rack_fillet_v2 (compute-only port) ----------
  function eval_rc_from_dy(dy_try, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy){
    const yrl = y_end0 - dy_try;
    const xrl = x_end0 + slope_dxdy*(yrl - y_end0);

    const phir = phir0;
    const delta = delta0;

    let rc = (yrl + Math.tan(phir)*xrl + Cf*m - Math.tan(phir)*(K0 - delta/2)) /
             (1 - Math.cos(phir) - Math.tan(phir)*Math.sin(phir));

    const yrend = rc*(1 - Math.cos(phir)) - Cf*m;

    if (yrend > yrl){
      rc = (yrl + Cf*m) / (1 - Math.cos(phir));
    }

    const xtest = (-Cf*m - yrl - Math.tan(phir)*xrl) / (-Math.tan(phir));
    const useLowerLine = (xtest > K0);

    if (useLowerLine){
      const yrpr = yrl - offset*m;
      const xrpr = (yrpr - yrl - Math.tan(phir)*xrl) / (-Math.tan(phir));
      rc = (yrpr + Math.tan(phir_new)*xrpr + Cf*m - Math.tan(phir_new)*(K0 - delta0/2)) /
           (1 - Math.cos(phir_new) - Math.tan(phir_new)*Math.sin(phir_new));
    }
    return rc;
  }

  function rack_fillet_v2(m, Z, xr_in, yr_in, Cf, cdel, rc_target, phir_new, offset){
    let xr = xr_in.slice();
    let yr = yr_in.slice();

    if (xr.length !== yr.length || xr.length < 2) throw new Error("rack_fillet: xr/yr must have same length and at least 2 points.");

    // Ensure lower end at END
    if (yr[yr.length-1] > yr[0]){
      xr.reverse(); yr.reverse();
    }

    const dx_last = xr[xr.length-1] - xr[xr.length-2];
    const dy_last = yr[yr.length-1] - yr[yr.length-2];
    if (Math.abs(dy_last) < 1e-12) throw new Error("rack_fillet: last rack segment has dy≈0.");

    const slope_dxdy = dx_last / dy_last;
    const x_end0 = xr[xr.length-1];
    const y_end0 = yr[yr.length-1];

    const ro = m*Z/2;
    const theta_rack_0 = 0.495*Math.PI/Z;
    const K0 = theta_rack_0*ro + 0.495*Math.PI*m/2;
    const delta0 = cdel*m;

    const arack_end0 = (yr[yr.length-2] - yr[yr.length-1]) / (xr[xr.length-2] - xr[xr.length-1]);
    const phir0 = Math.atan(-arack_end0);

    // Solve dy_ext
    let dy_ext;
    if (rc_target == null || !isFinite(rc_target) || rc_target <= 0){
      dy_ext = 0.15*m;
    } else {
      const tol_rc = 1e-6*Math.max(1, Math.abs(rc_target));
      const max_iter = 45;

      let dy_lo = 0.0;
      let f_lo = eval_rc_from_dy(dy_lo, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy) - rc_target;

      let dy_hi = 0.15*m;
      let f_hi = eval_rc_from_dy(dy_hi, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy) - rc_target;

      const dy_hi_max = 20*m;
      let k_expand = 0;
      while ((f_lo*f_hi > 0) && (dy_hi < dy_hi_max) && (k_expand < 30)){
        dy_hi = Math.min(dy_hi*1.6 + 1e-6, dy_hi_max);
        f_hi = eval_rc_from_dy(dy_hi, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy) - rc_target;
        k_expand++;
      }

      if (f_lo*f_hi <= 0){
        // Bisection
        dy_ext = dy_hi;
        for (let it=0; it<max_iter; it++){
          const dy_mid = 0.5*(dy_lo + dy_hi);
          const f_mid = eval_rc_from_dy(dy_mid, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy) - rc_target;

          if (Math.abs(f_mid) < tol_rc || Math.abs(dy_hi-dy_lo) < 1e-10){
            dy_ext = dy_mid; break;
          }
          if (f_lo*f_mid <= 0){
            dy_hi = dy_mid;
          } else {
            dy_lo = dy_mid; f_lo = f_mid;
          }
          dy_ext = dy_mid;
        }
      } else {
        // Secant fallback
        let dy0 = 0.0, f0 = f_lo;
        let dy1 = 0.15*m, f1 = eval_rc_from_dy(dy1, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy) - rc_target;
        dy_ext = dy1;

        for (let it=0; it<max_iter; it++){
          const den = (f1 - f0);
          let dy2;
          if (Math.abs(den) < 1e-14){
            dy2 = Math.min(dy1 + 0.05*m, dy_hi_max);
          } else {
            dy2 = dy1 - f1*(dy1-dy0)/den;
            dy2 = clamp(dy2, 0.0, dy_hi_max);
          }
          const f2 = eval_rc_from_dy(dy2, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy) - rc_target;

          dy0 = dy1; f0 = f1;
          dy1 = dy2; f1 = f2;
          dy_ext = dy2;

          if (Math.abs(f2) < tol_rc) break;
        }
      }
    }

    // Extend rack downward
    if (dy_ext > 1e-12){
      const y_end1 = y_end0 - dy_ext;
      const stepext = 1.5e-3;
      const Next = Math.max(5, Math.ceil(Math.abs(y_end1 - y_end0)/stepext));
      const y_ext = linspace(y_end0, y_end1, Next+1).slice(1);
      const x_ext = y_ext.map(yv => xr[xr.length-1] + slope_dxdy*(yv - y_end0));
      xr = xr.concat(x_ext);
      yr = yr.concat(y_ext);
    }

    const arack_end = (yr[yr.length-2] - yr[yr.length-1]) / (xr[xr.length-2] - xr[xr.length-1]);
    let phir = Math.atan(-arack_end);

    const xrlptc = xr[xr.length-1];
    const yrlptc = yr[yr.length-1];

    let delta = cdel*m;

    let rc = (yrlptc + Math.tan(phir)*xrlptc + Cf*m - Math.tan(phir)*(K0 - delta/2)) /
             (1 - Math.cos(phir) - Math.tan(phir)*Math.sin(phir));

    let yrc0 = -Cf*m + rc;
    let xrc0 = K0 - delta/2;

    let xrend = -rc*Math.sin(phir) + xrc0;
    let yrend =  rc*(1 - Math.cos(phir)) - Cf*m;

    if (yrend > yrlptc){
      yrend = yrlptc;
      xrend = xrlptc;
      rc = (yrlptc + Cf*m) / (1 - Math.cos(phir));
      delta = 2*(K0 - xrlptc - rc*Math.sin(phir));
      yrc0 = -Cf*m + rc;
      xrc0 = K0 - delta/2;
    }

    const xtest = (-Cf*m - yrlptc - Math.tan(phir)*xrlptc) / (-Math.tan(phir));
    const useLowerLine = (xtest > K0);

    let xrpr=NaN, yrpr=NaN;
    let phiArc = phir;

    if (useLowerLine){
      yrpr = yrlptc - offset*m;
      xrpr = (yrpr - yrlptc - Math.tan(phir)*xrlptc) / (-Math.tan(phir));

      rc = (yrpr + Math.tan(phir_new)*xrpr + Cf*m - Math.tan(phir_new)*(K0 - delta/2)) /
           (1 - Math.cos(phir_new) - Math.tan(phir_new)*Math.sin(phir_new));

      yrc0 = -Cf*m + rc;
      xrc0 = K0 - delta/2;

      xrend = -rc*Math.sin(phir_new) + xrc0;
      yrend =  rc*(1 - Math.cos(phir_new)) - Cf*m;

      phiArc = phir_new;
    }

    // Straight segment(s)
    let xr_lin = [], yr_lin = [], dydx_lin = [];
    let steplin = 1.5e-3;
    if (Math.abs(yrlptc - yrend) < steplin){
      steplin = Math.abs(yrlptc - yrend)/5 + 1e-12;
    }

    if (!useLowerLine){
      let ylin = [];
      for (let yv=yrlptc; yv>=yrend; yv-=steplin) ylin.push(yv);
      if (ylin.length===0 || ylin[ylin.length-1] !== yrend) ylin.push(yrend);

      const xlin = ylin.map(yv => (yv - (yrlptc + Math.tan(phir)*xrlptc)) / (-Math.tan(phir)));
      xr_lin = xlin;
      yr_lin = ylin;
      dydx_lin = ylin.map(() => -Math.tan(phir));
    } else {
      let ylin1 = [];
      for (let yv=yrlptc; yv>=yrpr; yv-=steplin) ylin1.push(yv);
      if (ylin1.length===0 || ylin1[ylin1.length-1] !== yrpr) ylin1.push(yrpr);

      const xlin1 = ylin1.map(yv => (yv - (yrlptc + Math.tan(phir)*xrlptc)) / (-Math.tan(phir)));

      let steplin2 = steplin;
      if (Math.abs(yrpr - yrend) < steplin2){
        steplin2 = Math.abs(yrpr - yrend)/5 + 1e-12;
      }
      let ylin2 = [];
      for (let yv=yrpr; yv>=yrend; yv-=steplin2) ylin2.push(yv);
      if (ylin2.length===0 || ylin2[ylin2.length-1] !== yrend) ylin2.push(yrend);

      const xlin2 = ylin2.map(yv => (yv - (yrpr + Math.tan(phir_new)*xrpr)) / (-Math.tan(phir_new)));

      xr_lin = xlin1.concat(xlin2.slice(1));
      yr_lin = ylin1.concat(ylin2.slice(1));
      dydx_lin = ylin1.map(() => -Math.tan(phir)).concat(ylin2.slice(1).map(() => -Math.tan(phir_new)));
    }

    // Arc phiArc -> 0
    const dphi = deg2rad(0.5);
    let thrc = [];
    for (let t=phiArc; t>=0; t-=dphi) thrc.push(t);
    if (thrc.length===0 || thrc[thrc.length-1] !== 0) thrc.push(0);

    const xr_rc = thrc.map(t => -rc*Math.sin(t) + xrc0);
    const yr_rc = thrc.map(t => -rc*Math.cos(t) + yrc0);
    const dydx_rc = thrc.map(t => -Math.tan(t));

    const xr_tr = xr_lin.concat(xr_rc);
    const yr_tr = yr_lin.concat(yr_rc);
    const dydx_tr = dydx_lin.concat(dydx_rc);

    // Map to pinion-centered frame
    const x_pin_tr = new Array(xr_tr.length);
    const y_pin_tr = new Array(xr_tr.length);

    for (let i=0;i<xr_tr.length;i++){
      const K_tr = -(yr_tr[i]*dydx_tr[i] + xr_tr[i]);
      const th = K_tr / ro;
      x_pin_tr[i] = (xr_tr[i] + K_tr)*Math.cos(th) - (yr_tr[i] + ro)*Math.sin(th);
      y_pin_tr[i] = (xr_tr[i] + K_tr)*Math.sin(th) + (yr_tr[i] + ro)*Math.cos(th);
    }

    return { x_pin_tr, y_pin_tr };
  }

  // ---------- gear_generator (FEA-ready) ----------
  function snapEndToStart(A, B, tol){
    if (!A || !B || A.length===0 || B.length===0) return [A,B];
    const pA = A[A.length-1];
    const pB = B[0];
    const gap = Math.hypot(pA[0]-pB[0], pA[1]-pB[1]);
    if (gap <= tol){
      const p = [0.5*(pA[0]+pB[0]), 0.5*(pA[1]+pB[1])];
      A[A.length-1] = p;
      B[0] = p;
    }
    return [A,B];
  }
  function dedupeConsecutive(P){
    if (!P || P.length<2) return P;
    const out = [P[0]];
    for (let i=1;i<P.length;i++){
      const a = out[out.length-1], b = P[i];
      if (a[0] !== b[0] || a[1] !== b[1]) out.push(b);
    }
    return out;
  }

  function gear_generator(x, y, x_tr, y_tr, Z){
    if (x.length < 2 || y.length < 2 || x.length !== y.length) throw new Error("gear_generator: invalid x,y.");
    if (x_tr.length < 2 || y_tr.length < 2 || x_tr.length !== y_tr.length) throw new Error("gear_generator: invalid x_tr,y_tr.");
    if (!(Z>=3 && Number.isInteger(Z))) throw new Error("gear_generator: Z must be integer >=3.");

    // Enforce ordering
    const r_in = x.map((vx,i)=> Math.hypot(vx,y[i]));
    if (r_in[0] < r_in[r_in.length-1]){
      x = x.slice().reverse(); y = y.slice().reverse();
    }
    const r_tr = x_tr.map((vx,i)=> Math.hypot(vx,y_tr[i]));
    if (r_tr[r_tr.length-1] > r_tr[0]){
      x_tr = x_tr.slice().reverse(); y_tr = y_tr.slice().reverse();
    }

    // Legacy addendum arc
    const th_pin_div_k = 40;
    const rA = Math.hypot(x[0], y[0]);
    const th_tip_R = Math.atan2(x[0], y[0]);
    const th_tip_L = Math.atan2(-x[0], y[0]);

    const th_k = linspace(th_tip_L, th_tip_R, th_pin_div_k+1);
    const xk = th_k.slice(1,-1).map(t => rA*Math.sin(t));
    const yk = th_k.slice(1,-1).map(t => rA*Math.cos(t));

    // Legacy tooth outline (for full-gear outline)
    const th_div_f = 20;
    const rF = Math.hypot(x_tr[x_tr.length-1], y_tr[y_tr.length-1]);
    const th_root_R = Math.atan2(x_tr[x_tr.length-1], y_tr[y_tr.length-1]);
    const th_root_L = Math.atan2(-x_tr[x_tr.length-1], y_tr[y_tr.length-1]);
    const th_root_L_next = th_root_L + 2*Math.PI/Z;

    const th_f = linspace(th_root_R, th_root_L_next, th_div_f+1);
    const xf = th_f.slice(1,-1).map(t => rF*Math.sin(t));
    const yf = th_f.slice(1,-1).map(t => rF*Math.cos(t));

    const x_tooth_legacy = [];
    const y_tooth_legacy = [];

    // left trochoid
    for (let i=x_tr.length-1;i>=0;i--){
      x_tooth_legacy.push(-x_tr[i]); y_tooth_legacy.push(y_tr[i]);
    }
    // left involute
    for (let i=x.length-1;i>=0;i--){
      x_tooth_legacy.push(-x[i]); y_tooth_legacy.push(y[i]);
    }
    // addendum
    for (let i=0;i<xk.length;i++){
      x_tooth_legacy.push(xk[i]); y_tooth_legacy.push(yk[i]);
    }
    // right involute
    for (let i=0;i<x.length;i++){
      x_tooth_legacy.push(x[i]); y_tooth_legacy.push(y[i]);
    }
    // right trochoid
    for (let i=0;i<x_tr.length;i++){
      x_tooth_legacy.push(x_tr[i]); y_tooth_legacy.push(y_tr[i]);
    }
    // root arc to next pitch
    for (let i=0;i<xf.length;i++){
      x_tooth_legacy.push(xf[i]); y_tooth_legacy.push(yf[i]);
    }

    // Full gear by rotation (legacy outline)
    const Ntooth = x_tooth_legacy.length;
    const x_tot = new Array(Z*Ntooth + 1);
    const y_tot = new Array(Z*Ntooth + 1);

    for (let k=1;k<=Z;k++){
      const rot = -(k-1)*2*Math.PI/Z;
      const c = Math.cos(rot), s = Math.sin(rot);
      const istart = (k-1)*Ntooth;
      for (let i=0;i<Ntooth;i++){
        const xx = x_tooth_legacy[i], yy = y_tooth_legacy[i];
        x_tot[istart+i] = xx*c - yy*s;
        y_tot[istart+i] = xx*s + yy*c;
      }
    }
    x_tot[x_tot.length-1] = x_tot[0];
    y_tot[y_tot.length-1] = y_tot[0];

    // ---------- FEA sector segments (root circle trimmed at ±π/Z) ----------
    const thetaB_L = -Math.PI/Z;
    const thetaB_R =  Math.PI/Z;

    const th_tip_L2 = Math.atan2(-x[0], y[0]);
    const th_tip_R2 = Math.atan2( x[0], y[0]);

    const th_root_R2 = Math.atan2( x_tr[x_tr.length-1], y_tr[y_tr.length-1]);
    const th_root_L2 = Math.atan2(-x_tr[x_tr.length-1], y_tr[y_tr.length-1]);

    const NrootSeg = 40;
    const NaddSeg  = 80;

    let seg = {};
    seg.rootL = (th_root_L2 > thetaB_L) ? arcXY(rF, thetaB_L, th_root_L2, NrootSeg, true) : [];
    seg.troL  = x_tr.slice().reverse().map((vx,i)=> [-vx, y_tr[y_tr.length-1-i]]);
    seg.invL  = x.slice().reverse().map((vx,i)=> [-vx, y[y.length-1-i]]);
    seg.add   = arcXY(rA, th_tip_L2, th_tip_R2, NaddSeg, true);
    seg.invR  = x.map((vx,i)=> [vx, y[i]]);
    seg.troR  = x_tr.map((vx,i)=> [vx, y_tr[i]]);
    seg.rootR = (thetaB_R > th_root_R2) ? arcXY(rF, th_root_R2, thetaB_R, NrootSeg, true) : [];

    // Snap junctions
    const tolSnap = Math.max(1e-6, 1e-3*Math.max(1, rA));
    [seg.rootL, seg.troL] = snapEndToStart(seg.rootL, seg.troL, tolSnap);
    [seg.troL,  seg.invL] = snapEndToStart(seg.troL,  seg.invL,  tolSnap);
    [seg.invL,  seg.add ] = snapEndToStart(seg.invL,  seg.add,   tolSnap);
    [seg.add,   seg.invR] = snapEndToStart(seg.add,   seg.invR,  tolSnap);
    [seg.invR,  seg.troR] = snapEndToStart(seg.invR,  seg.troR,  tolSnap);
    [seg.troR,  seg.rootR]= snapEndToStart(seg.troR,  seg.rootR, tolSnap);

    for (const k of ["rootL","troL","invL","add","invR","troR","rootR"]){
      seg[k] = dedupeConsecutive(seg[k]);
    }

    return { x_tot, y_tot, seg };
  }

  // ---------- Connector guard (flank end -> trochoid start) ----------
  function prepend_connector_if_needed(x_in, y_in, xtr_in, ytr_in, Nbridge=25){
    if (!x_in.length || !xtr_in.length) return {xtr:xtr_in, ytr:ytr_in};
    const p_end = [x_in[x_in.length-1], y_in[y_in.length-1]];
    const p0 = [xtr_in[0], ytr_in[0]];
    const d = Math.hypot(p_end[0]-p0[0], p_end[1]-p0[1]);
    if (d < 1e-9) return {xtr:xtr_in, ytr:ytr_in};

    Nbridge = Math.max(5, Math.round(Nbridge));
    const xb = linspace(p_end[0], p0[0], Nbridge);
    const yb = linspace(p_end[1], p0[1], Nbridge);

    const xtr_new = xb.slice(0,-1).concat(xtr_in);
    const ytr_new = yb.slice(0,-1).concat(ytr_in);
    return {xtr:xtr_new, ytr:ytr_new};
  }

  // ---------- Drawing ----------
  function drawGeometry(bundle){
    const cv = ui.cv;
    const ctx = cv.getContext("2d");
    const dpr = window.devicePixelRatio || 1;

    const cssW = cv.clientWidth;
    const cssH = cv.clientHeight;
    cv.width = Math.round(cssW * dpr);
    cv.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    ctx.clearRect(0,0,cssW,cssH);

    const showGear = ui.showGear.checked;
    const showCircles = ui.showCircles.checked;

    const tooth = state.lastTooth;
    if (!tooth) return;

    const pointsToDraw = [];
    if (showGear && state.lastGear){
      const xg = state.lastGear.x_tot;
      const yg = state.lastGear.y_tot;
      for (let i=0;i<xg.length;i++) pointsToDraw.push([xg[i], yg[i]]);
    } else {
      for (let i=0;i<tooth.x_tooth.length;i++) pointsToDraw.push([tooth.x_tooth[i], tooth.y_tooth[i]]);
    }

    // Fit bounds
    let xmin=+Infinity, xmax=-Infinity, ymin=+Infinity, ymax=-Infinity;
    for (const [x,y] of pointsToDraw){
      xmin = Math.min(xmin,x); xmax = Math.max(xmax,x);
      ymin = Math.min(ymin,y); ymax = Math.max(ymax,y);
    }

    const rMax = bundle ? bundle.ra1 : 1;
    if (showCircles){
      xmin = Math.min(xmin, -rMax); xmax = Math.max(xmax, rMax);
      ymin = Math.min(ymin, -rMax); ymax = Math.max(ymax, rMax);
    }

    const w = xmax-xmin, h = ymax-ymin;
    const pad = 18;
    const sx = (cssW - 2*pad) / (w || 1);
    const sy = (cssH - 2*pad) / (h || 1);
    const s = Math.min(sx, sy);

    const cx = pad + (cssW - 2*pad)/2;
    const cy = pad + (cssH - 2*pad)/2;
    const mx = (xmin+xmax)/2;
    const my = (ymin+ymax)/2;

    function X(x){ return cx + (x - mx)*s; }
    function Y(y){ return cy - (y - my)*s; }

    // Reference circles
    if (showCircles){
      ctx.save();
      ctx.lineWidth = 1;
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = "rgba(255,255,255,0.20)";

      drawCircle(ctx, X(0), Y(0), bundle.rf1*s);
      drawCircle(ctx, X(0), Y(0), bundle.ro1*s);
      drawCircle(ctx, X(0), Y(0), bundle.rb1*s);
      drawCircle(ctx, X(0), Y(0), bundle.ra1*s);

      ctx.restore();

      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText("Root", X(0)+8, Y(0)-bundle.rf1*s+14);
      ctx.fillText("Pitch", X(0)+8, Y(0)-bundle.ro1*s+14);
      ctx.fillText("Base", X(0)+8, Y(0)-bundle.rb1*s+14);
      ctx.fillText("Addendum", X(0)+8, Y(0)-bundle.ra1*s+14);
      ctx.restore();
    }

    // Draw outline
    ctx.save();
    ctx.lineWidth = 2.2;
    ctx.strokeStyle = "rgba(122,162,255,0.95)";
    ctx.beginPath();
    for (let i=0;i<pointsToDraw.length;i++){
      const [x,y] = pointsToDraw[i];
      const px = X(x), py = Y(y);
      if (i===0) ctx.moveTo(px,py);
      else ctx.lineTo(px,py);
    }
    ctx.stroke();
    ctx.restore();

    // Draw LOA
    if (state.lastLOA){
      const {x_LOA, y_LOA} = state.lastLOA;
      ctx.save();
      ctx.lineWidth = 1.6;
      ctx.strokeStyle = "rgba(61,220,151,0.9)";
      ctx.beginPath();
      for (let i=0;i<x_LOA.length;i++){
        const px = X(x_LOA[i]), py = Y(y_LOA[i]);
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawCircle(ctx, cx, cy, r){
    ctx.beginPath();
    ctx.arc(cx, cy, Math.max(0,r), 0, 2*Math.PI);
    ctx.stroke();
  }

  // ---------- Main compute ----------
  function compute(){
    try{
      const m = parseFloat(ui.m.value);
      const alphaDeg = parseFloat(ui.alpha.value);
      const alphaRad = deg2rad(alphaDeg);
      const z1 = parseInt(ui.z1.value, 10);
      const z2 = parseInt(ui.z2.value, 10);
      const Ck = parseFloat(ui.Ck.value);
      const Cf = parseFloat(ui.Cf.value);
      const rc = parseFloat(ui.rc.value);
      const N = parseInt(ui.N.value, 10);

      const base = computeInvoluteLOAandProfile({m,z1,z2,alphaRad,Ck,Cf,N});

      // UI outputs
      ui.eps.textContent = fmt(base.eps, 5);
      ui.loaLen.textContent = fmt(base.loaLen, 4) + " mm";
      ui.pb.textContent = fmt(base.pb, 4) + " mm";

      ui.r1.textContent  = fmt(base.ro1, 6);
      ui.rb1.textContent = fmt(base.rb1, 6);
      ui.ra1.textContent = fmt(base.ra1, 6);
      ui.rf1.textContent = fmt(base.rf1, 6);

      // Rack inputs for rack_fillet (ensure yr decreases to end)
      let xrRack = base.xrLOA.slice();
      let yrRack = base.yrLOA.slice();
      if (yrRack[yrRack.length-1] > yrRack[0]){
        xrRack.reverse(); yrRack.reverse();
      }

      // Root completion
      const cdel = 0.0;
      const phir_new = deg2rad(75);
      const offset = 0.9;
      const rc_target = (isFinite(rc) && rc>0) ? rc : (0.1*m);

      const fil = rack_fillet_v2(m, z1, xrRack, yrRack, Cf, cdel, rc_target, phir_new, offset);

      // Working flank in pinion-centered frame
      const x_pin = base.xPP.slice();
      const y_pin = base.yPP.map(v => v + base.ro1);

      // Phase convention
      const to = m*Math.PI;
      const So = to*0.495;
      const rot = -0.5*So/base.ro1;

      // Rotate RIGHT side
      const xR = [], yR = [];
      for (let i=0;i<x_pin.length;i++){
        const [xx,yy] = rotateXY(x_pin[i], y_pin[i], rot);
        xR.push(xx); yR.push(yy);
      }

      const xTr = [], yTr = [];
      for (let i=0;i<fil.x_pin_tr.length;i++){
        const [xx,yy] = rotateXY(fil.x_pin_tr[i], fil.y_pin_tr[i], rot);
        xTr.push(xx); yTr.push(yy);
      }

      // Enforce ordering
      const r_in = xR.map((vx,i)=> Math.hypot(vx,yR[i]));
      let x_in = xR.slice(), y_in = yR.slice();
      if (r_in[0] < r_in[r_in.length-1]){
        x_in.reverse(); y_in.reverse();
      }

      const r_tr = xTr.map((vx,i)=> Math.hypot(vx,yTr[i]));
      let xtr_in = xTr.slice(), ytr_in = yTr.slice();
      if (r_tr[r_tr.length-1] > r_tr[0]){
        xtr_in.reverse(); ytr_in.reverse();
      }

      // Connector guard
      const bridged = prepend_connector_if_needed(x_in, y_in, xtr_in, ytr_in, 25);
      xtr_in = bridged.xtr; ytr_in = bridged.ytr;

      // Build full gear + FEA segments
      const gg = gear_generator(x_in, y_in, xtr_in, ytr_in, z1);

      // ---------------------------
      // CHANGE: Tooth preview/CSV is sector boundary built from FEA segments:
      // rootL → troL → invL → add → invR → troR → rootR
      // This trims the root circle exactly at θ = -π/Z and +π/Z.
      // ---------------------------
      const order = ["rootL","troL","invL","add","invR","troR","rootR"];
      const x_tooth_sector = [];
      const y_tooth_sector = [];
      for (const k of order){
        const P = gg.seg[k] || [];
        for (const p of P){
          x_tooth_sector.push(p[0]);
          y_tooth_sector.push(p[1]);
        }
      }

      // Store state
      state.last = base;
      state.lastProfilePP = { x_pp: base.xPP.slice(), y_pp: base.yPP.slice() };
      state.lastTooth = { x_tooth: x_tooth_sector, y_tooth: y_tooth_sector };
      state.lastGear  = { x_tot: gg.x_tot, y_tot: gg.y_tot };
      state.lastSeg   = gg.seg;
      state.lastLOA   = { x_LOA: base.xLOA.slice(), y_LOA: base.yLOA.slice() };

      setStatus("ok",
        `Computed successfully. ε<sub>α</sub> = <span class="mono">${fmt(base.eps,5)}</span> · ` +
        `LOA = <span class="mono">${fmt(base.loaLen,4)}</span> mm · ` +
        `p<sub>b</sub> = <span class="mono">${fmt(base.pb,4)}</span> mm`
      );

      drawGeometry(base);

    } catch(err){
      console.error(err);
      ui.eps.textContent = "—";
      ui.loaLen.textContent = "—";
      ui.pb.textContent = "—";
      ui.r1.textContent = "—";
      ui.rb1.textContent = "—";
      ui.ra1.textContent = "—";
      ui.rf1.textContent = "—";
      state.last = null;
      state.lastProfilePP = null;
      state.lastTooth = null;
      state.lastGear = null;
      state.lastSeg = null;
      state.lastLOA = null;

      setStatus("bad", `Error: <span class="mono">${String(err.message || err)}</span>`);
      const ctx = ui.cv.getContext("2d");
      ctx.clearRect(0,0,ui.cv.width, ui.cv.height);
    }
  }

  // ---------- CSV exports ----------
  ui.btnCSV_Profile.addEventListener("click", () => {
    if (!state.last || !state.lastProfilePP){
      setStatus("warn","Nothing to export. Compute first.");
      return;
    }
    const {x_pp,y_pp} = state.lastProfilePP;
    const rows = [["idx","x_pp_mm","y_pp_mm"]];
    for (let i=0;i<x_pp.length;i++){
      rows.push([String(i+1), String(x_pp[i]), String(y_pp[i])]);
    }
    downloadCSV("pinion_profile_pitch_point.csv", rows);
  });

  ui.btnCSV_Tooth.addEventListener("click", () => {
    if (!state.lastTooth){
      setStatus("warn","Nothing to export. Compute first.");
      return;
    }
    const {x_tooth,y_tooth} = state.lastTooth;
    const rows = [["x_mm","y_mm"]];
    for (let i=0;i<x_tooth.length;i++){
      rows.push([String(x_tooth[i]), String(y_tooth[i])]);
    }
    downloadCSV("tooth_outline.csv", rows);
  });

  ui.btnCSV_Gear.addEventListener("click", () => {
    if (!state.lastGear){
      setStatus("warn","Nothing to export. Compute first.");
      return;
    }
    const {x_tot,y_tot} = state.lastGear;
    const rows = [["x_mm","y_mm"]];
    for (let i=0;i<x_tot.length;i++){
      rows.push([String(x_tot[i]), String(y_tot[i])]);
    }
    downloadCSV("gear_outline_full.csv", rows);
  });

  ui.btnCSV_Segment.addEventListener("click", () => {
    if (!state.lastSeg){
      setStatus("warn","Nothing to export. Compute first.");
      return;
    }
    const key = ui.segSelect.value;
    const seg = state.lastSeg[key];
    if (!seg || seg.length===0){
      setStatus("warn","Selected segment is empty for this geometry.");
      return;
    }
    const rows = [["x_mm","y_mm"]];
    for (const p of seg){
      rows.push([String(p[0]), String(p[1])]);
    }
    const mapName = {
      rootL:"01_rootCircle_L",
      troL:"02_trochoid_L",
      invL:"03_involute_L",
      add:"04_addendumArc",
      invR:"05_involute_R",
      troR:"06_trochoid_R",
      rootR:"07_rootCircle_R"
    };
    downloadCSV(`${mapName[key]}.csv`, rows);
  });

  // ---------- Events ----------
  ui.btnCompute.addEventListener("click", compute);

  function maybeAuto(){
    if (ui.autoCompute.checked) compute();
  }

  ["input","change"].forEach(evt => {
    ui.m.addEventListener(evt, maybeAuto);
    ui.alpha.addEventListener(evt, maybeAuto);
    ui.z1.addEventListener(evt, maybeAuto);
    ui.z2.addEventListener(evt, maybeAuto);
    ui.Ck.addEventListener(evt, maybeAuto);
    ui.Cf.addEventListener(evt, maybeAuto);
    ui.rc.addEventListener(evt, maybeAuto);
    ui.N.addEventListener(evt, maybeAuto);
    ui.showGear.addEventListener(evt, () => state.last && drawGeometry(state.last));
    ui.showCircles.addEventListener(evt, () => state.last && drawGeometry(state.last));
  });

  window.addEventListener("resize", () => state.last && drawGeometry(state.last));

  // Initial run
  compute();

})();
</script>
</body>
</html>

